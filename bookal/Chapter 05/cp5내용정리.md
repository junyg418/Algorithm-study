---
title: "탐색 알고리즘"
excerpt: "탐색 알고리즘 DFS/BFS"

categories:
  -algorithm
tags:
  -algorithm

date: 2022-04-12
last_modified_at: 2022-04-12
---
탐색(search): 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정  
탐색 알고리즘 종류  
 + DFS  
 + BFS  


자료구조(Data Structure):데이터를 표현하고 관리하고 처리하기 위한 구조  
  
기본 자료구조  
스택(Stack): 선입후출, 후입선출구조  
큐(Queue): 선입선출구조  
>collections 모듈의 deque 자료구조 매우 추천  
>from collections import deque  

+삽입(Push): 데이터를 삽입한다.  
+삭제(Pop): 데이터를 삭제한다.  
추가로 오버플로(Overflow), 언더플로(Underflow)를 고민해야한다.  

## 그래프  
  
그래프는 **노드(Node)** 와 **간선(Edge)** 으로 표현되며  
하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다.  
프로그래밍에서는 크게 2가지 방식으로 표현 할 수 있다.  
 + 인접 행렬(Adjacency Matrix): 2차원 배열로 그래프의 연결 관계를 표현하는 방식  
-> 파이썬에서는 2차원 list자료형으로 표현 할 수 있다  
ex)
```
INF = 999999999 #연결이 되어 있지 않은 노드끼리는 무한의 비용으로 작성

#2차원 리스트를 이용해 인접 행렬 표현
graph - [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]
```

 + 인접 리스트(Adjacency List): 리스트로 그래프의 연결 관계를 표현하는 방식  
ex)  
```
#행(Row)이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

#노드 0에 연결된 노드 정보 저장(노드, 거리(비용))
graph[0].append((1, 7))
graph[0].append((2, 5))

#노드 1에 연결된 노드 정보 저장(노드, 거리(비용))
graph[1].append((0, 7))

#노드 2에 연결된 노드 정보 저장(노드, 거리(비용))
graph[2].append((0, 5))
```

### 인접행렬 vs 인접리스트  
  
#### 인접행렬
-> 모든 관계 저장  
 + 노드↑ 메보리를 불필요하게 낭비  
 + 비교적 특정 노드간 연결 확인 속도↑  

#### 인접 리스트
-> 연결된 정보만 저장
 + 메모리 효율적
 + 비교적 특정노드간 연결확인 속도↓  
  -하나하나 확인해야하기에  
  
ex)  
노드 1, 노드 7 이 연결되어있는 상황  
 인접 행렬방식  
->graph[1][7]만 확인하면 됨
 인접 리스트 방식  
 ->노드 1에 대한 인접리스트를 앞에서부터 차례대로 확인해야함  

## DFS

**DFS** 는 Depth-Fist Serch, 깊이 우선 탐색이라고 부르며,  
그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘 이다.  
>특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가 노드를 방문후  
>다시 돌아가 다른 경로로 탐색하는 알고리즘    
<!-- --2022-04-12 -->