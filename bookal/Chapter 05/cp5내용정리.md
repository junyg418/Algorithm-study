---
title: "탐색 알고리즘"
excerpt: "탐색 알고리즘 DFS/BFS"

categories:
  -algorithm
tags:
  -algorithm

date: 2022-04-12
last_modified_at: 2022-04-12
---
탐색(search): 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정  
탐색 알고리즘 종류  
 + DFS  
 + BFS  


자료구조(Data Structure):데이터를 표현하고 관리하고 처리하기 위한 구조  
  
기본 자료구조  
스택(Stack): 선입후출, 후입선출구조  
큐(Queue): 선입선출구조  
>collections 모듈의 deque 자료구조 매우 추천  
>from collections import deque  

+삽입(Push): 데이터를 삽입한다.  
+삭제(Pop): 데이터를 삭제한다.  
추가로 오버플로(Overflow), 언더플로(Underflow)를 고민해야한다.  

## 그래프  
  
그래프는 **노드(Node)** 와 **간선(Edge)** 으로 표현되며  
하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다.  
프로그래밍에서는 크게 2가지 방식으로 표현 할 수 있다.  
 + 인접 행렬(Adjacency Matrix): 2차원 배열로 그래프의 연결 관계를 표현하는 방식  
-> 파이썬에서는 2차원 list자료형으로 표현 할 수 있다  
ex)
```
INF = 999999999 #연결이 되어 있지 않은 노드끼리는 무한의 비용으로 작성

#2차원 리스트를 이용해 인접 행렬 표현
graph - [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]
```

 + 인접 리스트(Adjacency List): 리스트로 그래프의 연결 관계를 표현하는 방식  
ex)  
```
#행(Row)이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

#노드 0에 연결된 노드 정보 저장(노드, 거리(비용))
graph[0].append((1, 7))
graph[0].append((2, 5))

#노드 1에 연결된 노드 정보 저장(노드, 거리(비용))
graph[1].append((0, 7))

#노드 2에 연결된 노드 정보 저장(노드, 거리(비용))
graph[2].append((0, 5))
```

### 인접행렬 vs 인접리스트  
  
#### 인접행렬
-> 모든 관계 저장  
 + 노드↑ 메보리를 불필요하게 낭비  
 + 비교적 특정 노드간 연결 확인 속도↑  

#### 인접 리스트
-> 연결된 정보만 저장
 + 메모리 효율적
 + 비교적 특정노드간 연결확인 속도↓  
  -하나하나 확인해야하기에  
  
ex)  
노드 1, 노드 7 이 연결되어있는 상황  
 인접 행렬방식  
->graph[1][7]만 확인하면 됨
 인접 리스트 방식  
 ->노드 1에 대한 인접리스트를 앞에서부터 차례대로 확인해야함  

## DFS

**DFS** 는 Depth-Fist Serch, '깊이 우선 탐색'이라고 부르며,  
그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘 이다.  
>특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가 노드를 방문후  
>다시 돌아가 다른 경로로 탐색하는 알고리즘  
<!-- --2022-04-12 -->
 1. 탐색 시작 노드를 스택에 삽입하고 방문처리 한다.  
 2.스택의 __최상단 노드에 방문하지 않은 인접 노드__ 가 있으면  
 그 인접 노드를 스택에 넣고 방문 처리를 한다.
 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.  
 3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.  
  
 __tip__ '방문처리'는 스택에 한 번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는 것을 의미한다.  
 방문처리를 함으로서 각 노드를 한 번씩만 처리할 수 잇다.  

ex)  
```
# DFS 메서드 정의
def dfs(graph, v, visited):
    #현재 노드를 방문 처리
    visited[v] = True
    print(v, end='')
    #현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)
```

## BFS  

**BFS** 는 Breadth Firs Search, '너비 우선 탐색'라고 부르며,  
가까운 노드부터 탐색하는 알고리즘이다.  
>선입선출 방식인 큐자료구조를 이용하는 것이 정석이다.  
>deque 라이브러리를 사용하는 것이 좋으며 탐색을 수행함에 있어 O(N)의 시간이 소요된다.  
 1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.  
 2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 녿를 모두 큐에 삽입하고 방문처리를 한다.  
 3. 2번의 과정을 더 이상 수행할 수 없을 떄까지 반복한다.  

ex)  
```
from collections import deque

# BFS 메서드 정의
def bfs(graph, start, visited):
    #큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    #현재 노드를 방문 처리
    visited[start] = True
    # 큐가 빌 때까지 반복
    while queue:
        v = queue.popleft()
        print(v, end='')
        #해당 원소랑 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

graph = [ #각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
    '원소들 9개'
]

#각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9
#함수 호출
bfs(graph, 1, visited)
```

## DFS vs BFS
  
 |  |  DFS  |  BFS |
 |:--- | :---: | :---: |    
 |  동작원리  |  스택  | 큐 |  
 | 구현 방법 | 재귀함수 이용 | 큐 자료구조 이용 |
 | 수행 시간 | 비교적 느림 | 비교적 빠름 |

참조 : 이것이 코딩 테스트다 with 파이썬